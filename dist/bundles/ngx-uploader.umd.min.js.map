{"version":3,"file":"ngx-uploader.umd.min.js","sources":["../../../node_modules/src/util/tryCatch.ts","../../../node_modules/src/Subscription.ts","../../../node_modules/src/util/pipe.ts","~/ngx-uploader/src/ngx-uploader/classes/ngx-uploader.class.ts","../../../node_modules/src/util/root.ts","../../../node_modules/src/util/isArrayLike.ts","../../../node_modules/src/util/isPromise.ts","../../../node_modules/src/util/isObject.ts","../../../node_modules/src/util/isFunction.ts","../../../node_modules/src/util/isArray.ts","../../../node_modules/src/util/errorObject.ts","../../../node_modules/src/util/UnsubscriptionError.ts","../../../node_modules/src/Observer.ts","../../../node_modules/src/symbol/rxSubscriber.ts","../../../node_modules/src/Subscriber.ts","../../../node_modules/src/util/toSubscriber.ts","../../../node_modules/src/symbol/observable.ts","../../../node_modules/src/util/noop.ts","../../../node_modules/src/Observable.ts","../../../node_modules/src/symbol/iterator.ts","../../../node_modules/src/InnerSubscriber.ts","../../../node_modules/src/util/subscribeToResult.ts","../../../node_modules/src/OuterSubscriber.ts","../../../node_modules/src/operators/mergeMap.ts","~/ngx-uploader/src/ngx-uploader/classes/interfaces.ts","~/ngx-uploader/src/ngx-uploader/directives/ng-file-select.directive.ts","~/ngx-uploader/src/ngx-uploader/directives/ng-file-drop.directive.ts","~/ngx-uploader/src/ngx-uploader/module/ngx-uploader.module.ts"],"sourcesContent":["import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n};\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  readonly closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  protected _parent: Subscription = null;\n  protected _parents: Subscription[] = null;\n  private _subscriptions: ISubscription[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input);\n  };\n}\n","import {EventEmitter} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Subject} from 'rxjs/Subject';\nimport {Subscription} from 'rxjs/Subscription';\nimport {mergeMap} from 'rxjs/operators/mergeMap';\nimport {BlobFile, UploadFile, UploadInput, UploadOutput, UploadStatus} from './interfaces';\n/**\n * @param {?} bytes\n * @return {?}\n */\nexport function humanizeBytes(bytes: number): string {\n    if (bytes === 0) {\n        return '0 Byte';\n    }\n\n    const /** @type {?} */ k = 1024;\n    const /** @type {?} */ sizes: string[] = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n    const /** @type {?} */ i: number = Math.floor(Math.log(bytes) / Math.log(k));\n\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\nexport class NgUploaderService {\n    queue: UploadFile[];\n    serviceEvents: EventEmitter<UploadOutput>;\n    uploadScheduler: Subject<{ file: UploadFile, event: UploadInput }>;\n    subs: { id: string, sub: Subscription }[];\n    contentTypes: string[];\n    concurrency: number = Number.POSITIVE_INFINITY;\n/**\n * @param {?=} concurrency\n * @param {?=} contentTypes\n */\nconstructor(concurrency: number = Number.POSITIVE_INFINITY, contentTypes: string[] = ['*']) {\n        this.queue = [];\n        this.serviceEvents = new EventEmitter<UploadOutput>();\n        this.subs = [];\n        this.contentTypes = contentTypes;\n        this.concurrency = concurrency;\n        this.initUploadScheduler();\n    }\n/**\n * @return {?}\n */\ninitUploadScheduler() {\n        this.uploadScheduler = new Subject();\n        this.uploadScheduler\n            .pipe(\n                mergeMap(upload => this.startUpload(upload), this.concurrency)\n            )\n            .subscribe(uploadOutput => this.serviceEvents.emit(uploadOutput));\n\n    }\n/**\n * @param {?} incomingFiles\n * @return {?}\n */\nhandleFiles(incomingFiles: FileList): void {\n        const /** @type {?} */ allowedIncomingFiles: File[] = [].reduce.call(incomingFiles, (acc: File[], checkFile: File, i: number) => {\n            if (this.isContentTypeAllowed(checkFile.type)) {\n                acc = acc.concat(checkFile);\n            } else {\n                const /** @type {?} */ rejectedFile: UploadFile = this.makeUploadFile(checkFile, i);\n                this.serviceEvents.emit({type: 'rejected', file: rejectedFile});\n            }\n\n            return acc;\n        }, []);\n\n        this.queue.push(...[].map.call(allowedIncomingFiles, (file: File, i: number) => {\n            const /** @type {?} */ uploadFile: UploadFile = this.makeUploadFile(file, i);\n            this.serviceEvents.emit({type: 'addedToQueue', file: uploadFile});\n            return uploadFile;\n        }));\n\n        this.serviceEvents.emit({type: 'allAddedToQueue'});\n    }\n/**\n * @param {?} input\n * @return {?}\n */\ninitInputEvents(input: EventEmitter<UploadInput>): Subscription {\n        return input.subscribe((event: UploadInput) => {\n            switch (event.type) {\n                case 'uploadFile':\n                    const /** @type {?} */ uploadFileIndex = this.queue.findIndex(file => file === event.file);\n                    if (uploadFileIndex !== -1 && event.file) {\n                        this.uploadScheduler.next({file: this.queue[uploadFileIndex], event: event});\n                    }\n                    break;\n                case 'uploadAll':\n                    const /** @type {?} */ files = this.queue.filter(file => file.progress.status === UploadStatus.Queue);\n                    files.forEach(file => this.uploadScheduler.next({file: file, event: event}));\n                    break;\n                case 'cancel':\n                    const /** @type {?} */ id = event.id || null;\n                    if (!id) {\n                        return;\n                    }\n\n                    const /** @type {?} */ index = this.subs.findIndex(sub => sub.id === id);\n                    if (index !== -1 && this.subs[index].sub) {\n                        this.initUploadScheduler();\n                        this.subs[index].sub.unsubscribe();\n\n                        const /** @type {?} */ fileIndex = this.queue.findIndex(file => file.id === id);\n                        if (fileIndex !== -1) {\n                            this.queue[fileIndex].progress.status = UploadStatus.Cancelled;\n                            this.serviceEvents.emit({type: 'cancelled', file: this.queue[fileIndex]});\n                        }\n                    }\n                    break;\n                case 'cancelAll':\n                    this.subs.forEach(sub => {\n                        if (sub.sub) {\n                            sub.sub.unsubscribe();\n                        }\n\n                        const /** @type {?} */ file = this.queue.find(uploadFile => uploadFile.id === sub.id);\n                        if (file) {\n                            file.progress.status = UploadStatus.Cancelled;\n                            this.serviceEvents.emit({type: 'cancelled', file: file});\n                        }\n                    });\n                    break;\n                case 'remove':\n                    if (!event.id) {\n                        return;\n                    }\n\n                    const /** @type {?} */ i = this.queue.findIndex(file => file.id === event.id);\n                    if (i !== -1) {\n                        const /** @type {?} */ file = this.queue[i];\n                        this.queue.splice(i, 1);\n                        this.serviceEvents.emit({type: 'removed', file: file});\n                    }\n                    break;\n                case 'removeAll':\n                    if (this.queue.length) {\n                        this.queue = [];\n                        this.serviceEvents.emit({type: 'removedAll'});\n                    }\n                    break;\n            }\n        });\n    }\n/**\n * @param {?} upload\n * @return {?}\n */\nstartUpload(upload: { file: UploadFile, event: UploadInput }): Observable<UploadOutput> {\n        return new Observable(observer => {\n            const /** @type {?} */ sub = this.uploadFile(upload.file, upload.event)\n                .subscribe(output => {\n                    observer.next(output);\n                }, err => {\n                    observer.error(err);\n                    observer.complete();\n                }, () => {\n                    observer.complete();\n                });\n\n            this.subs.push({id: upload.file.id, sub: sub});\n        });\n    }\n/**\n * @param {?} file\n * @param {?} event\n * @return {?}\n */\nuploadFile(file: UploadFile, event: UploadInput): Observable<UploadOutput> {\n        return new Observable(observer => {\n            const /** @type {?} */ url = event.url || '';\n            const /** @type {?} */ method = event.method || 'POST';\n            const /** @type {?} */ data = event.data || {};\n            const /** @type {?} */ headers = event.headers || {};\n\n            const /** @type {?} */ xhr = new XMLHttpRequest();\n            const /** @type {?} */ time: number = new Date().getTime();\n            let /** @type {?} */ progressStartTime: number = (file.progress.data && file.progress.data.startTime) || time;\n            let /** @type {?} */ speed = 0;\n            let /** @type {?} */ eta: number | null = null;\n\n            xhr.upload.addEventListener('progress', (e: ProgressEvent) => {\n                if (e.lengthComputable) {\n                    const /** @type {?} */ percentage = Math.round((e.loaded * 100) / e.total);\n                    const /** @type {?} */ diff = new Date().getTime() - time;\n                    speed = Math.round(e.loaded / diff * 1000);\n                    progressStartTime = (file.progress.data && file.progress.data.startTime) || new Date().getTime();\n                    eta = Math.ceil((e.total - e.loaded) / speed);\n\n                    file.progress = {\n                        status: UploadStatus.Uploading,\n                        data: {\n                            percentage: percentage,\n                            speed: speed,\n                            speedHuman: `${humanizeBytes(speed)}/s`,\n                            startTime: progressStartTime,\n                            endTime: null,\n                            eta: eta,\n                            etaHuman: this.secondsToHuman(eta)\n                        }\n                    };\n\n                    observer.next({type: 'uploading', file: file});\n                }\n            }, false);\n\n            xhr.upload.addEventListener('error', (e: Event) => {\n                observer.error(e);\n                observer.complete();\n            });\n\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState === XMLHttpRequest.DONE) {\n                    const /** @type {?} */ speedAverage = Math.round(file.size / (new Date().getTime() - progressStartTime) * 1000);\n                    file.progress = {\n                        status: UploadStatus.Done,\n                        data: {\n                            percentage: 100,\n                            speed: speedAverage,\n                            speedHuman: `${humanizeBytes(speedAverage)}/s`,\n                            startTime: progressStartTime,\n                            endTime: new Date().getTime(),\n                            eta: eta,\n                            etaHuman: this.secondsToHuman(eta || 0)\n                        }\n                    };\n\n                    file.responseStatus = xhr.status;\n\n                    try {\n                        file.response = JSON.parse(xhr.response);\n                    }\n                    catch ( /** @type {?} */e) {\n                        file.response = xhr.response;\n                    }\n\n                    file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());\n\n                    observer.next({type: 'done', file: file});\n\n                    observer.complete();\n                }\n            };\n\n            xhr.open(method, url, true);\n            xhr.withCredentials = event.withCredentials ? true : false;\n\n            try {\n                const /** @type {?} */ uploadFile = /** @type {?} */(( <BlobFile>file.nativeFile));\n                const /** @type {?} */ uploadIndex = this.queue.findIndex(outFile => outFile.nativeFile === uploadFile);\n\n                if (this.queue[uploadIndex].progress.status === UploadStatus.Cancelled) {\n                    observer.complete();\n                }\n\n                Object.keys(data).forEach(key => file.form.append(key, data[key]));\n                Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n\n                file.form.append(event.fieldName || 'file', uploadFile, uploadFile.name);\n\n                this.serviceEvents.emit({type: 'start', file: file});\n                xhr.send(file.form);\n            }\n            catch ( /** @type {?} */e) {\n                observer.complete();\n            }\n\n            return () => {\n                xhr.abort();\n            };\n        });\n    }\n/**\n * @param {?} sec\n * @return {?}\n */\nsecondsToHuman(sec: number): string {\n        return new Date(sec * 1000).toISOString().substr(11, 8);\n    }\n/**\n * @return {?}\n */\ngenerateId(): string {\n        return Math.random().toString(36).substring(7);\n    }\n/**\n * @param {?} contentTypes\n * @return {?}\n */\nsetContentTypes(contentTypes: string[]): void {\n        if (typeof contentTypes != 'undefined' && contentTypes instanceof Array) {\n            if (contentTypes.find((type: string) => type === '*') !== undefined) {\n                this.contentTypes = ['*'];\n            } else {\n                this.contentTypes = contentTypes;\n            }\n            return;\n        }\n        this.contentTypes = ['*'];\n    }\n/**\n * @return {?}\n */\nallContentTypesAllowed(): boolean {\n        return this.contentTypes.find((type: string) => type === '*') !== undefined;\n    }\n/**\n * @param {?} mimetype\n * @return {?}\n */\nisContentTypeAllowed(mimetype: string): boolean {\n        if (this.allContentTypesAllowed()) {\n            return true;\n        }\n        return this.contentTypes.find((type: string) => type === mimetype) !== undefined;\n    }\n/**\n * @param {?} file\n * @param {?} index\n * @return {?}\n */\nmakeUploadFile(file: File, index: number): UploadFile {\n        return {\n            fileIndex: index,\n            id: this.generateId(),\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            form: new FormData(),\n            progress: {\n                status: UploadStatus.Queue,\n                data: {\n                    percentage: 0,\n                    speed: 0,\n                    speedHuman: `${humanizeBytes(0)}/s`,\n                    startTime: null,\n                    endTime: null,\n                    eta: null,\n                    etaHuman: null\n                }\n            },\n            lastModifiedDate: file.lastModifiedDate,\n            sub: undefined,\n            nativeFile: file\n        };\n    }\n/**\n * @param {?} httpHeaders\n * @return {?}\n */\nprivate parseResponseHeaders(httpHeaders: ByteString) {\n        if (!httpHeaders) {\n            return;\n        }\n        return httpHeaders.split('\\n')\n            .map(x => x.split(/: */, 2))\n            .filter(x => x[0])\n            .reduce((ac, x) => {\n                ac[x[0]] = x[1];\n                return ac;\n            }, {});\n    }\n}\n\nfunction NgUploaderService_tsickle_Closure_declarations() {\n/** @type {?} */\nNgUploaderService.prototype.queue;\n/** @type {?} */\nNgUploaderService.prototype.serviceEvents;\n/** @type {?} */\nNgUploaderService.prototype.uploadScheduler;\n/** @type {?} */\nNgUploaderService.prototype.subs;\n/** @type {?} */\nNgUploaderService.prototype.contentTypes;\n/** @type {?} */\nNgUploaderService.prototype.concurrency;\n}\n\n","declare let global: any;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\n\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _root: any = __window || __global || __self;\n\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n  if (!_root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n  }\n})();\n\nexport { _root as root };","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number');","export function isPromise<T>(value: any | Promise<T>): value is Promise<T> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport const errorObject: any = { e: {} };","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super();\n    const err: any = Error.call(this, errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (<any> this).name = err.name = 'UnsubscriptionError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","export interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void { throw err; },\n  complete(): void { /*noop*/ }\n};\n","import { root } from '../util/root';\n\nconst Symbol: any = root.Symbol;\n\nexport const rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n  Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = (<Subscriber<any>> destinationOrNext);\n            (<any> this.destination).add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  protected _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  protected _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { PartialObserver, empty as emptyObserver } from '../Observer';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { root } from '../util/root';\n\nexport function getSymbolObservable(context: any) {\n  let $$observable: any;\n  let Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n        $$observable = Symbol('observable');\n        Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexport const observable = getSymbolObservable(root);\n\n/**\n * @deprecated use observable instead\n */\nexport const $$observable = observable;\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { OperatorFunction } from './interfaces';\nimport { pipeFromArray } from './util/pipe';\n\nexport interface Subscribable<T> {\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): AnonymousSubscription;\n}\n\nexport type SubscribableOrPromise<T> = Subscribable<T> | PromiseLike<T>;\nexport type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  public _isScalar: boolean = false;\n\n  protected source: Observable<any>;\n  protected operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * @example <caption>Subscribe with an Observer</caption>\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Subscribe with functions</caption>\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Cancel a subscription</caption>\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   *\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  }\n\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.syncErrorThrown = true;\n      sink.syncErrorValue = err;\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void> {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  }\n\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words\n  static if: typeof IfObservable.create;\n  static throw: typeof ErrorObservable.create;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * @example\n   *\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(PromiseCtor?: PromiseConstructorLike) {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n","import { root } from '../util/root';\n\nexport function symbolIteratorPonyfill(root: any) {\n  const Symbol: any = root.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (!Symbol.iterator) {\n      Symbol.iterator = Symbol('iterator polyfill');\n    }\n    return Symbol.iterator;\n  } else {\n    // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n    const { Set } = root;\n    if (Set && typeof new Set()['@@iterator'] === 'function') {\n      return '@@iterator';\n    }\n    const { Map } = root;\n    // required for compatability with es6-shim\n    if (Map) {\n      let keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        let key = keys[i];\n        // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n        if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {\n          return key;\n        }\n      }\n    }\n    return '@@iterator';\n  }\n}\n\nexport const iterator = symbolIteratorPonyfill(root);\n\n/**\n * @deprecated use iterator instead\n */\nexport const $$iterator = iterator;\n","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index: number = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, private outerValue: T, private outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","import { root } from './root';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription {\n  let destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable) {\n    if (result._isScalar) {\n      destination.next((<any>result).value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike(result)) {\n    for (let i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise(result)) {\n    result.then(\n      (value) => {\n        if (!destination.closed) {\n          destination.next(<any>value);\n          destination.complete();\n        }\n      },\n      (err: any) => destination.error(err)\n    )\n    .then(null, (err: any) => {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root.setTimeout(() => { throw err; });\n    });\n    return destination;\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    const iterator = <any>result[Symbol_iterator]();\n    do {\n      let item = iterator.next();\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n      destination.next(item.value);\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    const obs = result[Symbol_observable]();\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n  return null;\n}\n","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","import { Observable, ObservableInput } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>,\n                                  resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number,\n                                  concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, I|R> {\n  return function mergeMapOperatorFunction(source: Observable<T>) {\n    if (typeof resultSelector === 'number') {\n      concurrent = <number>resultSelector;\n      resultSelector = null;\n    }\n    return source.lift(new MergeMapOperator(project, <any>resultSelector, concurrent));\n  };\n}\n\nexport class MergeMapOperator<T, I, R> implements Operator<T, I> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<I>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.resultSelector, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<I>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<I>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(ish: ObservableInput<I>, value: T, index: number): void {\n    this.add(subscribeToResult<T, I>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    if (this.resultSelector) {\n      this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  }\n\n  private _notifyResultSelector(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) {\n    let result: R;\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Subscription } from 'rxjs/Subscription';\n\nexport interface UploaderOptions {\n  concurrency: number;\n  allowedContentTypes?: string[];\n}\n\nexport interface BlobFile extends Blob {\n  name: string;\n}\nexport type UploadStatus = number;\nexport let UploadStatus: any = {};\nUploadStatus.Queue = 0;\nUploadStatus.Uploading = 1;\nUploadStatus.Done = 2;\nUploadStatus.Cancelled = 3;\nUploadStatus[UploadStatus.Queue] = \"Queue\";\nUploadStatus[UploadStatus.Uploading] = \"Uploading\";\nUploadStatus[UploadStatus.Done] = \"Done\";\nUploadStatus[UploadStatus.Cancelled] = \"Cancelled\";\n\n\nexport interface UploadProgress {\n  status: UploadStatus;\n  data?: {\n    percentage: number;\n    speed: number;\n    speedHuman: string;\n    startTime: number | null;\n    endTime: number | null;\n    eta: number | null;\n    etaHuman: string | null;\n  };\n}\n\nexport interface UploadFile {\n  id: string;\n  fileIndex: number;\n  lastModifiedDate: Date;\n  name: string;\n  size: number;\n  type: string;\n  form: FormData;\n  progress: UploadProgress;\n  response?: any;\n  responseStatus?: number;\n  sub?: Subscription | any;\n  nativeFile?: File;\n  responseHeaders?: { [key: string]: string };\n}\n\nexport interface UploadOutput {\n  type: 'addedToQueue' | 'allAddedToQueue' | 'uploading' | 'done' | 'start' | 'cancelled' | 'dragOver'\n      | 'dragOut' | 'drop' | 'removed' | 'removedAll' | 'rejected';\n  file?: UploadFile;\n  nativeFile?: File;\n}\n\nexport interface UploadInput {\n  type: 'uploadAll' | 'uploadFile' | 'cancel' | 'cancelAll' | 'remove' | 'removeAll';\n  url?: string;\n  method?: string;\n  id?: string;\n  fieldName?: string;\n  fileIndex?: number;\n  file?: UploadFile;\n  data?: { [key: string]: string | Blob };\n  headers?: { [key: string]: string };\n  withCredentials?: boolean;\n}\n","import { Directive, ElementRef, EventEmitter, Input, Output, OnInit, OnDestroy } from '@angular/core';\nimport { UploadOutput, UploaderOptions, NgUploaderService } from '../../../';\nimport { Subscription } from 'rxjs/Subscription';\nexport class NgFileSelectDirective implements OnInit, OnDestroy {\n   options: UploaderOptions;\n   uploadInput: EventEmitter<any>;\n   uploadOutput: EventEmitter<UploadOutput>;\n\n  upload: NgUploaderService;\n  el: HTMLInputElement;\n\n  _sub: Subscription[];\n/**\n * @param {?} elementRef\n */\nconstructor(public elementRef: ElementRef) {\n    this.uploadOutput = new EventEmitter<UploadOutput>();\n  }\n/**\n * @return {?}\n */\nngOnInit() {\n    this._sub = [];\n    const /** @type {?} */ concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n    const /** @type {?} */ allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes);\n\n    this.el = this.elementRef.nativeElement;\n    this.el.addEventListener('change', this.fileListener, false);\n\n    this._sub.push(\n      this.upload.serviceEvents.subscribe((event: UploadOutput) => {\n        this.uploadOutput.emit(event);\n      })\n    );\n\n    if (this.uploadInput instanceof EventEmitter) {\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (this.el){\n      this.el.removeEventListener('change', this.fileListener, false);\n      this._sub.forEach(sub => sub.unsubscribe());\n    }\n  }\n\n  fileListener = () => {\n    if (this.el.files) {\n      this.upload.handleFiles(this.el.files);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[ngFileSelect]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'options': [{ type: Input },],\n'uploadInput': [{ type: Input },],\n'uploadOutput': [{ type: Output },],\n};\n}\n\nfunction NgFileSelectDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nNgFileSelectDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgFileSelectDirective.ctorParameters;\n/** @type {?} */\nNgFileSelectDirective.propDecorators;\n/** @type {?} */\nNgFileSelectDirective.prototype.options;\n/** @type {?} */\nNgFileSelectDirective.prototype.uploadInput;\n/** @type {?} */\nNgFileSelectDirective.prototype.uploadOutput;\n/** @type {?} */\nNgFileSelectDirective.prototype.upload;\n/** @type {?} */\nNgFileSelectDirective.prototype.el;\n/** @type {?} */\nNgFileSelectDirective.prototype._sub;\n/** @type {?} */\nNgFileSelectDirective.prototype.fileListener;\n/** @type {?} */\nNgFileSelectDirective.prototype.elementRef;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Directive, ElementRef, EventEmitter, Input, Output, OnInit, OnDestroy, HostListener } from '@angular/core';\nimport { UploadOutput, UploadInput, UploaderOptions, NgUploaderService } from '../../../';\nimport { Subscription } from 'rxjs/Subscription';\nexport class NgFileDropDirective implements OnInit, OnDestroy {\n   options: UploaderOptions;\n   uploadInput: EventEmitter<UploadInput>;\n   uploadOutput: EventEmitter<UploadOutput>;\n\n  upload: NgUploaderService;\n  el: HTMLInputElement;\n\n  _sub: Subscription[];\n/**\n * @param {?} elementRef\n */\nconstructor(public elementRef: ElementRef) {\n    this.uploadOutput = new EventEmitter<UploadOutput>();\n  }\n/**\n * @return {?}\n */\nngOnInit() {\n    this._sub = [];\n    const /** @type {?} */ concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n    const /** @type {?} */ allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes);\n\n    this.el = this.elementRef.nativeElement;\n\n    this._sub.push(\n      this.upload.serviceEvents.subscribe((event: UploadOutput) => {\n        this.uploadOutput.emit(event);\n      })\n    );\n\n    if (this.uploadInput instanceof EventEmitter) {\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\n    }\n\n    this.el.addEventListener('drop', this.stopEvent, false);\n    this.el.addEventListener('dragenter', this.stopEvent, false);\n    this.el.addEventListener('dragover', this.stopEvent, false);\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this._sub.forEach(sub => sub.unsubscribe());\n  }\n\n  stopEvent = (e: Event) => {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n/**\n * @param {?} e\n * @return {?}\n */\npublic onDrop(e: any) {\n    e.stopPropagation();\n    e.preventDefault();\n\n    const /** @type {?} */ event: UploadOutput = { type: 'drop' };\n    this.uploadOutput.emit(event);\n    this.upload.handleFiles(e.dataTransfer.files);\n  }\n/**\n * @param {?} e\n * @return {?}\n */\npublic onDragOver(e: Event) {\n    if (!e) {\n      return;\n    }\n\n    const /** @type {?} */ event: UploadOutput = { type: 'dragOver' };\n    this.uploadOutput.emit(event);\n  }\n/**\n * @param {?} e\n * @return {?}\n */\npublic onDragLeave(e: Event) {\n    if (!e) {\n      return;\n    }\n\n    const /** @type {?} */ event: UploadOutput = { type: 'dragOut' };\n    this.uploadOutput.emit(event);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[ngFileDrop]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'options': [{ type: Input },],\n'uploadInput': [{ type: Input },],\n'uploadOutput': [{ type: Output },],\n'onDrop': [{ type: HostListener, args: ['drop', ['$event'], ] },],\n'onDragOver': [{ type: HostListener, args: ['dragover', ['$event'], ] },],\n'onDragLeave': [{ type: HostListener, args: ['dragleave', ['$event'], ] },],\n};\n}\n\nfunction NgFileDropDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nNgFileDropDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgFileDropDirective.ctorParameters;\n/** @type {?} */\nNgFileDropDirective.propDecorators;\n/** @type {?} */\nNgFileDropDirective.prototype.options;\n/** @type {?} */\nNgFileDropDirective.prototype.uploadInput;\n/** @type {?} */\nNgFileDropDirective.prototype.uploadOutput;\n/** @type {?} */\nNgFileDropDirective.prototype.upload;\n/** @type {?} */\nNgFileDropDirective.prototype.el;\n/** @type {?} */\nNgFileDropDirective.prototype._sub;\n/** @type {?} */\nNgFileDropDirective.prototype.stopEvent;\n/** @type {?} */\nNgFileDropDirective.prototype.elementRef;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\nimport { NgFileDropDirective } from '../directives/ng-file-drop.directive';\nimport { NgFileSelectDirective } from '../directives/ng-file-select.directive';\nexport class NgUploaderModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [\n    NgFileSelectDirective,\n    NgFileDropDirective\n  ],\n  exports: [\n    NgFileSelectDirective,\n    NgFileDropDirective\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction NgUploaderModule_tsickle_Closure_declarations() {\n/** @type {?} */\nNgUploaderModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNgUploaderModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["tryCatcher","tryCatchTarget","apply","this","arguments","e","errorObject_1","errorObject","flattenUnsubscriptionErrors","errors","reduce","errs","err","concat","UnsubscriptionError_1","UnsubscriptionError","pipeFromArray","fns","length","input","prev","fn","noop_1","noop","humanizeBytes","bytes","i","Math","floor","log","parseFloat","pow","toFixed","__window","window","__self","self","WorkerGlobalScope","_root","global","root_1","Error","x","value","subscribe","then","Array","isArray","_super","call","map","toString","join","name","stack","message","__extends","Subscription","unsubscribe","closed","_parent","_parents","_subscriptions","_unsubscribe","prototype","hasErrors","index","len","remove","isFunction_1","isFunction","trial","tryCatch_1","tryCatch","isArray_1","sub","isObject_1","isObject","push","add","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","empty","next","error","complete","Symbol","root","exports","rxSubscriber","for","$$rxSubscriber","Subscriber","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","Observer_1","SafeSubscriber","rxSubscriber_1","create","subscriber","_next","_error","_complete","_unsubscribeAndRecycle","Subscription_1","Subscriber_2","_parentSubscriber","observerOrNext","context","Object","bind","_context","__tryOrSetError","__tryOrUnsub","_this","wrappedComplete","nextOrObserver","Subscriber_1","getSymbolObservable","$$observable","observable","_i","Observable$$1","_isScalar","_subscribe","Observable","lift","operator","source","sink","toSubscriber_1","toSubscriber","_trySubscribe","forEach","PromiseCtor","Rx","config","Promise","resolve","reject","observable_1","pipe","operations","pipe_1","toPromise","symbolIteratorPonyfill","iterator","Set_1","Set","Map_1","Map","keys","getOwnPropertyNames","key","$$iterator","InnerSubscriber","outerValue","outerIndex","notifyNext","notifyError","notifyComplete","outerSubscriber","result","InnerSubscriber_1","Observable_1","isArrayLike_1","isArrayLike","isPromise_1","isPromise","setTimeout","iterator_1","item","done","obs","TypeError","msg","OuterSubscriber","innerValue","innerIndex","innerSub","mergeMap_2","project","resultSelector","concurrent","Number","POSITIVE_INFINITY","MergeMapOperator","observer","MergeMapSubscriber","hasCompleted","buffer","active","_tryNext","_innerSub","ish","subscribeToResult_1","subscribeToResult","_notifyResultSelector","shift","OuterSubscriber_1","UploadStatus","Queue","Uploading","Done","Cancelled","NgUploaderService","concurrency","contentTypes","queue","serviceEvents","EventEmitter","subs","initUploadScheduler","uploadScheduler","Subject","mergeMap","upload","startUpload","uploadOutput","emit","handleFiles","incomingFiles","allowedIncomingFiles","acc","checkFile","isContentTypeAllowed","type","rejectedFile","makeUploadFile","file","_b","uploadFile","initInputEvents","event","uploadFileIndex","findIndex","filter","progress","status","id_1","id","fileIndex","find","output","url","method","data","headers","xhr","XMLHttpRequest","time","Date","getTime","progressStartTime","startTime","speed","eta","addEventListener","lengthComputable","percentage","round","loaded","total","diff","ceil","speedHuman","endTime","etaHuman","secondsToHuman","onreadystatechange","readyState","DONE","speedAverage","size","responseStatus","response","JSON","parse","responseHeaders","parseResponseHeaders","getAllResponseHeaders","open","withCredentials","uploadFile_1","uploadIndex","outFile","nativeFile","form","append","setRequestHeader","fieldName","send","abort","sec","toISOString","substr","generateId","random","substring","setContentTypes","undefined","allContentTypesAllowed","mimetype","FormData","lastModifiedDate","httpHeaders","split","ac","NgFileSelectDirective","elementRef","fileListener","el","files","ngOnInit","_sub","options","allowedContentTypes","nativeElement","uploadInput","ngOnDestroy","removeEventListener","decorators","Directive","args","selector","ctorParameters","ElementRef","propDecorators","Input","Output","NgFileDropDirective","stopEvent","stopPropagation","preventDefault","onDrop","dataTransfer","onDragOver","onDragLeave","HostListener","NgUploaderModule","NgModule","declarations"],"mappings":"wZAIA,SAAAA,IACE,IACE,OAAOC,EAAeC,MAAMC,KAAMC,WAClC,MAAOC,GAEP,OADAC,EAAJC,YAAgBF,EAAIA,EACTC,EAAXC,aCkNA,SAAAC,EAAqCC,GACpC,OAAOA,EAAOC,OAAO,SAACC,EAAMC,GAAQ,OAAAD,EAAKE,OAAQD,aAAeE,EAAjEC,oBAAwFH,EAAIH,OAASG,QCvMrG,SAAAI,EAAoCC,GAClC,OAAKA,EAIc,IAAfA,EAAIC,OACCD,EAAI,GAGN,SAAeE,GACpB,OAAOF,EAAIP,OAAO,SAACU,EAAWC,GAA4B,OAAAA,EAAGD,IAAOD,IAR7DG,EAAXC,KCbA,SAAAC,EAHCC,GAIG,GAHc,IAGVA,EACA,MAHO,SAMX,IADMC,EAAYC,KAAKC,MAAMD,KAAKE,IAAIJ,GAASE,KAAKE,IAF1C,OAOV,OAHOC,YAAYL,EAAQE,KAAKI,IAJtB,KAI6BL,IAAIM,QAAQ,IAAM,KAHjC,QAAU,KAAM,KAAM,KAAM,KAAM,MAGWN,8GCDnEO,EAA6B,oBAAXC,QAA0BA,OAC5CC,EAAyB,oBAATC,MAAqD,oBAAtBC,mBACjDD,gBAAgBC,mBAAqBD,KAEnCE,EAAaL,QADgB,IAAXM,GAA0BA,GACPJ,EAW3CK,EAAAF,GANA,WACE,IAAKA,EACH,MAAM,IAAIG,MAAM,iEAFpB,OJtBIxC,4BKFoB,SAAQyC,GAA8B,OAAAA,GAAyB,iBAAbA,EAAExB,sBCA5E,SAA6ByB,GAC3B,OAAOA,GAA2C,mBAArBA,EAAOC,WAA2D,mBAAvBD,EAAcE,mBCDxF,SAAyBH,GACvB,OAAY,MAALA,GAA0B,iBAANA,kBCD7B,SAA2BA,GACzB,MAAoB,mBAANA,eCDOI,MAAMC,SAAO,SAASL,GAAqB,OAAAA,GAAyB,iBAAbA,EAAExB,yBCC9Cb,mBVYlC,SAA6CgB,GAE3C,OADApB,EAAiBoB,EACLrB,kNWXd,SAAAgD,GACE,SAAFjC,EAAqBN,GACjBuC,EAAJC,KAAA9C,MADqBA,KAArBM,OAAqBA,EAEjB,IAAMG,EAAW6B,MAAMQ,KAAK9C,KAAMM,EAC7BA,EAAOS,OAAhB,8CACIT,EAAOyC,IAAI,SAACtC,EAAKc,GAAM,OAAGA,EAAI,EADlC,KACwCd,EAAIuC,aAAcC,KAAK,QAAY,IAChEjD,KAAMkD,KAAOzC,EAAIyC,KAAO,sBACxBlD,KAAMmD,MAAQ1C,EAAI0C,MAClBnD,KAAMoD,QAAU3C,EAAI2C,QAE/B,OAVyCC,EAAzCzC,EAAAiC,GAUAjC,EAVA,CAAyC0B,wBV0BzC,WAoBE,SAAFgB,EAAcC,GAVLvD,KAATwD,QAA2B,EAEfxD,KAAZyD,QAAoC,KACxBzD,KAAZ0D,SAAuC,KAC7B1D,KAAV2D,eAA4C,KAOpCJ,IACKvD,KAAM4D,aAAeL,GAqKlC,OA3JED,EAAFO,UAAAN,YAAE,WACE,IACIjD,EADAwD,GAAY,EAGhB,IAAI9D,KAAKwD,OAAT,CAIA,IAAMC,EAAVzD,KAAAyD,QAAmBC,EAAnB1D,KAAA0D,SAA6BE,EAA7B5D,KAAA4D,aAA2CD,EAA3C3D,KAAA2D,eAEI3D,KAAKwD,QAAS,EACdxD,KAAKyD,QAAU,KACfzD,KAAK0D,SAAW,KAGhB1D,KAAK2D,eAAiB,KAOtB,IALA,IAAII,GAAS,EACTC,EAAMN,EAAWA,EAAS3C,OAAS,EAIhC0C,GACLA,EAAQQ,OAAOjE,MAGfyD,IAAYM,EAAQC,GAAON,EAASK,IAAU,KAGhD,GAAIG,EAARC,WAAmBP,GAAe,EACxBQ,EAAQC,EAAlBC,SAA2BV,GAAcd,KAAK9C,SAC1BG,EAApBC,cACQ0D,GAAY,EACZxD,EAASA,IACPH,EADVC,YACsBF,aAAaS,EADnCC,oBAEYP,EAA4BF,EAAxCC,YAAoDF,EAAEI,SAAWH,EAAjEC,YAA6EF,KAKzE,GAAIqE,EAAR3B,QAAgBe,GAKV,IAHAI,GAAS,EACTC,EAAML,EAAe5C,SAEZgD,EAAQC,GAAK,CACpB,IAAMQ,EAAMb,EAAeI,GAC3B,GAAIU,EAAZC,SAAqBF,GAAM,CACjB,IAAIJ,EAAQC,EAAtBC,SAA+BE,EAAIjB,aAAaT,KAAK0B,GAC3C,GAAIJ,IAAUjE,EAAxBC,YAAqC,CACzB0D,GAAY,EACZxD,EAASA,MACT,IAAIG,EAAMN,EAAtBC,YAAkCF,EAClBO,aAAeE,EAA/BC,oBACcN,EAASA,EAAOI,OAAOL,EAA4BI,EAAIH,SAEvDA,EAAOqE,KAAKlE,KAOtB,GAAIqD,EACF,MAAM,IAAInD,EAAhBC,oBAAoCN,KAsBlCgD,EAAFO,UAAAe,IAAE,SAAIC,GACF,IAAKA,GAAaA,IAAavB,EAAawB,MAC1C,OAAOxB,EAAawB,MAGtB,GAAID,IAAa7E,KACf,OAAOA,KAGT,IAAI+E,EAA+BF,EAEnC,cAAeA,GACb,IAAK,WACHE,EAAe,IAAIzB,EAA6BuB,GAClD,IAAK,SACH,GAAIE,EAAavB,QAA8C,mBAA7BuB,EAAaxB,YAC7C,OAAOwB,EACF,GAAI/E,KAAKwD,OAEd,OADAuB,EAAaxB,cACNwB,EACF,GAAuC,mBAA5BA,EAAaC,WAA6C,CAC1E,IAAMC,EAAMF,GACZA,EAAe,IAAIzB,GACNK,gBAAkBsB,GAEjC,MACF,QACE,MAAM,IAAI3C,MAAM,yBAA2BuC,EAAW,2BAQ1D,OALsB7E,KAAK2D,iBAAmB3D,KAAK2D,oBAErCgB,KAAKI,GACnBA,EAAaC,WAAWhF,MAEjB+E,GASTzB,EAAFO,UAAAI,OAAE,SAAOc,GACL,IAAMG,EAAgBlF,KAAK2D,eAC3B,GAAIuB,EAAe,CACjB,IAAMC,EAAoBD,EAAcE,QAAQL,IACrB,IAAvBI,GACFD,EAAcG,OAAOF,EAAmB,KAKtC7B,EAAVO,UAAAmB,WAAE,SAAmBM,GACjB,IAAM7B,EAAVzD,KAAAyD,QAAmBC,EAAnB1D,KAAA0D,SACSD,GAAWA,IAAY6B,EAIhB5B,GAI6B,IAA9BA,EAAS0B,QAAQE,IAE1B5B,EAASiB,KAAKW,GAHdtF,KAAK0D,UAAY4B,GAJjBtF,KAAKyD,QAAU6B,GAhLLhC,EAAhBwB,MAAuC,SAASS,GAE5C,OADAA,EAAM/B,QAAS,EACR+B,EAFU,CAGjB,IAAIjC,GAuLRA,EA3LA,cWCEE,QAAQ,EACRgC,KAAF,SAAOhD,KACLiD,MAAF,SAAQhF,GAAkB,MAAMA,GAC9BiF,SAAF,iCChCA,IAAMC,EAActD,EAApBuD,KAAyBD,OAEZE,EAAbC,aAA+C,mBAAXH,GAA+C,mBAAfA,EAAOI,OACzEJ,EAAOI,OAAI,gBAAkB,iBAKlBF,EAAbG,eAA8BH,EAA9BC,wOCMAG,EAAA,SAAApD,GAsCE,SAAFoD,EAAcC,EACAT,EACAC,GAGV,OAFA7C,EAAJC,KAAA9C,MAlBSA,KAATmG,eAA+B,KACtBnG,KAAToG,iBAAoC,EAC3BpG,KAATqG,oBAAuC,EAE3BrG,KAAZsG,WAAiC,EAgBrBrG,UAAUc,QAChB,KAAK,EACHf,KAAKuG,YAAcC,EAA3BjB,MACQ,MACF,KAAK,EACH,IAAKW,EAAmB,CACtBlG,KAAKuG,YAAcC,EAA7BjB,MACU,MAEF,GAAiC,iBAAtBW,EAAgC,CACrCA,aAA6BD,GAC/BjG,KAAKqG,mBAAqBH,EAAkBG,mBAC5CrG,KAAKuG,YAAiCL,EAC/BlG,KAAKuG,YAAa3B,IAAI5E,QAE7BA,KAAKqG,oBAAqB,EAC1BrG,KAAKuG,YAAc,IAAIE,EAAkBzG,KAA6BkG,IAExE,MAEJ,QACElG,KAAKqG,oBAAqB,EAC1BrG,KAAKuG,YAAc,IAAIE,EAAkBzG,KAA6BkG,EAAmBT,EAAOC,IA8ExG,OA/ImCrC,EAAnC4C,EAAApD,GAEEoD,EAAFpC,UAAG6C,EAAHZ,cAAE,WAAyB,OAAO9F,MAazBiG,EAATU,OAAE,SAAiBnB,EACAC,EACAC,GACf,IAAMkB,EAAa,IAAIX,EAAWT,EAAMC,EAAOC,GAE/C,OADAkB,EAAWP,oBAAqB,EACzBO,GAyDTX,EAAFpC,UAAA2B,KAAE,SAAKhD,GACExC,KAAKsG,WACRtG,KAAK6G,MAAMrE,IAWfyD,EAAFpC,UAAA4B,MAAE,SAAMhF,GACCT,KAAKsG,YACRtG,KAAKsG,WAAY,EACjBtG,KAAK8G,OAAOrG,KAUhBwF,EAAFpC,UAAA6B,SAAE,WACO1F,KAAKsG,YACRtG,KAAKsG,WAAY,EACjBtG,KAAK+G,cAITd,EAAFpC,UAAAN,YAAE,WACMvD,KAAKwD,SAGTxD,KAAKsG,WAAY,EACjBzD,EAAJgB,UAAUN,YAAVT,KAAA9C,QAGYiG,EAAZpC,UAAAgD,MAAE,SAAgBrE,GACdxC,KAAKuG,YAAYf,KAAKhD,IAGdyD,EAAZpC,UAAAiD,OAAE,SAAiBrG,GACfT,KAAKuG,YAAYd,MAAMhF,GACvBT,KAAKuD,eAGG0C,EAAZpC,UAAAkD,UAAE,WACE/G,KAAKuG,YAAYb,WACjB1F,KAAKuD,eAGG0C,EAAZpC,UAAAmD,uBAAE,WACE,IAAQvD,EAAZzD,KAAAyD,QAAqBC,EAArB1D,KAAA0D,SAQI,OAPA1D,KAAKyD,QAAU,KACfzD,KAAK0D,SAAW,KAChB1D,KAAKuD,cACLvD,KAAKwD,QAAS,EACdxD,KAAKsG,WAAY,EACjBtG,KAAKyD,QAAUA,EACfzD,KAAK0D,SAAWA,EACT1D,MAEXiG,EA/IA,CAAmCgB,EA+InC3D,cA/IA4D,EAAAjB,EAsJAQ,EAAA,SAAA5D,GAIE,SAAF4D,EAAsBU,EACRC,EACA3B,EACAC,GACV7C,EAAJC,KAAA9C,MAJsBA,KAAtBmH,kBAAsBA,EAMlB,IAAI3B,EACA6B,EAAerH,KAEfkE,EAARC,WAAmBiD,GACb5B,EAA+B4B,EACtBA,IACT5B,EAA6B4B,EAAgB5B,KAC7CC,EAA8B2B,EAAgB3B,MAC9CC,EAAiC0B,EAAgB1B,SAC7C0B,IAAmBZ,EAA7BjB,QACQ8B,EAAUC,OAAOX,OAAOS,GACpBlD,EAAZC,WAAuBkD,EAAQ9D,cACrBvD,KAAK4E,IAAiByC,EAAQ9D,YAAYgE,KAAKF,IAEjDA,EAAQ9D,YAAcvD,KAAKuD,YAAYgE,KAAKvH,QAIhDA,KAAKwH,SAAWH,EAChBrH,KAAK6G,MAAQrB,EACbxF,KAAK8G,OAASrB,EACdzF,KAAK+G,UAAYrB,EAiFrB,OAhHgCrC,EAAhCoD,EAAA5D,GAkCE4D,EAAF5C,UAAA2B,KAAE,SAAKhD,GACH,IAAKxC,KAAKsG,WAAatG,KAAK6G,MAAO,CACzB,IAAdM,EAAAnH,KAAAmH,kBACWA,EAAkBd,mBAEZrG,KAAKyH,gBAAgBN,EAAmBnH,KAAK6G,MAAOrE,IAC7DxC,KAAKuD,cAFLvD,KAAK0H,aAAa1H,KAAK6G,MAAOrE,KAOpCiE,EAAF5C,UAAA4B,MAAE,SAAMhF,GACJ,IAAKT,KAAKsG,UAAW,CACX,IAAda,EAAAnH,KAAAmH,kBACM,GAAInH,KAAK8G,OACFK,EAAkBd,oBAIrBrG,KAAKyH,gBAAgBN,EAAmBnH,KAAK8G,OAAQrG,GACrDT,KAAKuD,gBAJLvD,KAAK0H,aAAa1H,KAAK8G,OAAQrG,GAC/BT,KAAKuD,mBAKF,CAAA,IAAK4D,EAAkBd,mBAE5B,MADArG,KAAKuD,cACC9C,EAEN0G,EAAkBhB,eAAiB1F,EACnC0G,EAAkBf,iBAAkB,EACpCpG,KAAKuD,iBAKXkD,EAAF5C,UAAA6B,SAAE,WAAA,IAAFiC,EAAA3H,KACI,IAAKA,KAAKsG,UAAW,CACX,IAAda,EAAAnH,KAAAmH,kBACM,GAAInH,KAAK+G,UAAW,CAClB,IAAMa,EAAkB,WAAM,OAAAD,EAAKZ,UAAUjE,KAAK6E,EAAKH,WAElDL,EAAkBd,oBAIrBrG,KAAKyH,gBAAgBN,EAAmBS,GACxC5H,KAAKuD,gBAJLvD,KAAK0H,aAAaE,GAClB5H,KAAKuD,oBAMPvD,KAAKuD,gBAKHkD,EAAV5C,UAAA6D,aAAE,SAAqBxG,EAAcsB,GACjC,IACEtB,EAAG4B,KAAK9C,KAAKwH,SAAUhF,GACvB,MAAO/B,GAEP,MADAT,KAAKuD,cACC9C,IAIFgG,EAAV5C,UAAA4D,gBAAE,SAAwBnC,EAAuBpE,EAAcsB,GAC3D,IACEtB,EAAG4B,KAAK9C,KAAKwH,SAAUhF,GACvB,MAAO/B,GAGP,OAFA6E,EAAOa,eAAiB1F,EACxB6E,EAAOc,iBAAkB,GAClB,EAET,OAAO,GAGCK,EAAZ5C,UAAAD,aAAE,WACU,IAAZuD,EAAAnH,KAAAmH,kBACInH,KAAKwH,SAAW,KAChBxH,KAAKmH,kBAAoB,KACzBA,EAAkB5D,eAEtBkD,EAhHA,CAAgCR,oCClKhC,SACE4B,EACApC,EACAC,GAEA,GAAImC,EAAgB,CAClB,GAAIA,aAA0BC,EAAlC7B,WACM,OAAwB4B,EAG1B,GAAIA,EAAenB,EAAvBZ,cACM,OAAO+B,EAAenB,EAA5BZ,gBAIE,OAAK+B,GAAmBpC,GAAUC,EAI3B,IAAIoC,EAAb7B,WAAwB4B,EAAgBpC,EAAOC,GAHpC,IAAIoC,EAAf7B,WAA0BO,EAA1BjB,2BClBA,SAAAwC,EAAoCV,GAClC,IAAIW,EACArC,EAAS0B,EAAQ1B,OAarB,MAXsB,mBAAXA,EACLA,EAAOsC,WACTD,EAAerC,EAAOsC,YAEpBD,EAAerC,EAAO,cACtBA,EAAOsC,WAAaD,GAGxBA,EAAe,eAGVA,EAfOnC,EAAhBkC,oBAAAA,EAkBalC,EAAboC,WAA0BF,EAAoB1F,EAA9CuD,MAKaC,EAAbmC,aAA4BnC,EAA5BoC,wECxBA,uBfeA,WAAA,IAA2B,IAA3BnH,KAAAoH,EAAA,EAA2BA,EAA3BjI,UAAAc,OAA2BmH,IAAApH,EAA3BoH,EAAA,GAAAjI,UAAAiI,GACE,OAAOrH,EAAcC,kBAIvBD,iBgBMA,WAcE,SAAFsH,EAAc1F,GAZLzC,KAAToI,WAA8B,EAatB3F,IACFzC,KAAKqI,WAAa5F,GAsTxB,OA7RE6F,EAAFzE,UAAA0E,KAAE,SAAQC,GACN,IAAMP,EAAa,IAAIK,EAGvB,OAFAL,EAAWQ,OAASzI,KACpBiI,EAAWO,SAAWA,EACfP,GAuHTK,EAAFzE,UAAApB,UAAE,SAAU2E,EACA3B,EACAC,GAEA,IAAZ8C,EAAAxI,KAAAwI,SACUE,EAAOC,EAAjBC,aAA8BxB,EAAgB3B,EAAOC,GAQjD,GANI8C,EACFA,EAAS1F,KAAK4F,EAAM1I,KAAKyI,QAEzBC,EAAK9D,IAAI5E,KAAKyI,SAAWC,EAAKrC,mBAAqBrG,KAAKqI,WAAWK,GAAQ1I,KAAK6I,cAAcH,IAG5FA,EAAKrC,qBACPqC,EAAKrC,oBAAqB,EACtBqC,EAAKtC,iBACP,MAAMsC,EAAKvC,eAIf,OAAOuC,GAGCJ,EAAZzE,UAAAgF,cAAE,SAAwBH,GACtB,IACE,OAAO1I,KAAKqI,WAAWK,GACvB,MAAOjI,GACPiI,EAAKtC,iBAAkB,EACvBsC,EAAKvC,eAAiB1F,EACtBiI,EAAKjD,MAAMhF,KAWf6H,EAAFzE,UAAAiF,QAAE,SAAQtD,EAA0BuD,GAAlC,IAAFpB,EAAA3H,KASI,GARK+I,IACC1G,EAAVuD,KAAeoD,IAAM3G,EAArBuD,KAA0BoD,GAAGC,QAAU5G,EAAvCuD,KAA4CoD,GAAGC,OAAOC,QAC9CH,EAAc1G,EAAtBuD,KAA2BoD,GAAGC,OAAOC,QACpB7G,EAAjBuD,KAAsBsD,UACdH,EAAc1G,EAAtBuD,KAA2BsD,WAIlBH,EACH,MAAM,IAAIzG,MAAM,yBAGlB,OAAO,IAAIyG,EAAkB,SAACI,EAASC,GAGrC,IAAIrE,EACJA,EAAe4C,EAAKlF,UAAU,SAACD,GAC7B,GAAIuC,EAKF,IACES,EAAKhD,GACL,MAAO/B,GACP2I,EAAO3I,GACPsE,EAAaxB,mBASfiC,EAAKhD,IAEN4G,EAAQD,MAILb,EAAZzE,UAAAwE,WAAE,SAAqBzB,GACnB,OAAO5G,KAAKyI,OAAOhG,UAAUmE,IAY/B0B,EAAFzE,UAAGwF,EAAHpB,YAAE,WACE,OAAOjI,MAkCTsI,EAAFzE,UAAAyF,KAAE,WAAF,IAAU,IAAVC,KAAArB,EAAA,EAAUA,EAAVjI,UAAAc,OAAUmH,IAAAqB,EAAVrB,EAAA,GAAAjI,UAAAiI,GACI,OAA0B,IAAtBqB,EAAWxI,OACNf,KAGFwJ,EAAX3I,cAAyB0I,EAAdC,CAA0BxJ,OASnCsI,EAAFzE,UAAA4F,UAAE,SAAUV,GAAV,IAAFpB,EAAA3H,KASI,GARK+I,IACC1G,EAAVuD,KAAeoD,IAAM3G,EAArBuD,KAA0BoD,GAAGC,QAAU5G,EAAvCuD,KAA4CoD,GAAGC,OAAOC,QAC9CH,EAAc1G,EAAtBuD,KAA2BoD,GAAGC,OAAOC,QACpB7G,EAAjBuD,KAAsBsD,UACdH,EAAc1G,EAAtBuD,KAA2BsD,WAIlBH,EACH,MAAM,IAAIzG,MAAM,yBAGlB,OAAO,IAAIyG,EAAY,SAACI,EAASC,GAC/B,IAAI5G,EACJmF,EAAKlF,UAAU,SAACF,GAAS,OAAAC,EAAQD,GAAG,SAAC9B,GAAa,OAAA2I,EAAO3I,IAAM,WAAM,OAAA0I,EAAQ3G,QArS1E8F,EAAT3B,OAA4B,SAAIlE,GAC5B,OAAO,IAAI6F,EAAc7F,IAuS7B6F,EAtUA,sBCzBA,SAAAoB,EAAuC9D,GACrC,IAAMD,EAAcC,EAAKD,OAEzB,GAAsB,mBAAXA,EAIT,OAHKA,EAAOgE,WACVhE,EAAOgE,SAAWhE,EAAO,sBAEpBA,EAAOgE,SAGN,IAAZC,EAAAhE,EAAAiE,IACI,GAAID,GAA0C,mBAA5B,IAAIA,GAAM,cAC1B,MAAO,aAED,IAAZE,EAAAlE,EAAAmE,IAEI,GAAID,EAEF,IAAK,IADDE,EAAO1C,OAAO2C,oBAAoBH,EAAIjG,WACjCtC,EAAI,EAAGA,EAAIyI,EAAKjJ,SAAUQ,EAAG,CACpC,IAAI2I,EAAMF,EAAKzI,GAEf,GAAY,YAAR2I,GAA6B,SAARA,GAAkBJ,EAAIjG,UAAUqG,KAASJ,EAAIjG,UAAmB,QACvF,OAAOqG,EAIb,MAAO,aA1BKrE,EAAhB6D,uBAAAA,EA8Ba7D,EAAb8D,SAAwBD,EAAuBrH,EAA/CuD,MAKaC,EAAbsE,WAA0BtE,EAA1B8D,wQC7BA,SAAA9G,GAGE,SAAFuH,EAAsB9E,EAAuC+E,EAAuBC,GAChFzH,EAAJC,KAAA9C,MADsBA,KAAtBsF,OAAsBA,EAAuCtF,KAA7DqK,WAA6DA,EAAuBrK,KAApFsK,WAAoFA,EAF1EtK,KAAV+D,MAA0B,EAmB1B,OApB2CV,EAA3C+G,EAAAvH,GAOYuH,EAAZvG,UAAAgD,MAAE,SAAgBrE,GACdxC,KAAKsF,OAAOiF,WAAWvK,KAAKqK,WAAY7H,EAAOxC,KAAKsK,WAAYtK,KAAK+D,QAAS/D,OAGtEoK,EAAZvG,UAAAiD,OAAE,SAAiBrB,GACfzF,KAAKsF,OAAOkF,YAAY/E,EAAOzF,MAC/BA,KAAKuD,eAGG6G,EAAZvG,UAAAkD,UAAE,WACE/G,KAAKsF,OAAOmF,eAAezK,MAC3BA,KAAKuD,eAET6G,EApBA,CAA2CtC,EAoB3C7B,kCCZA,SAAqCyE,EACAC,EACAN,EACAC,GACnC,IAAI/D,EAA+B,IAAIqE,EAAzCR,gBAAyDM,EAAiBL,EAAYC,GAEpF,GAAI/D,EAAY/C,OACd,OAAO,KAGT,GAAImH,aAAkBE,EAAxBvC,WACI,OAAIqC,EAAOvC,WACT7B,EAAYf,KAAWmF,EAAQnI,OAC/B+D,EAAYb,WACL,OAEPa,EAAYF,oBAAqB,EAC1BsE,EAAOlI,UAAU8D,IAErB,GAAIuE,EAAbC,YAAyBJ,GAAS,CAC9B,IAAK,IAAIpJ,EAAI,EAAGyC,EAAM2G,EAAO5J,OAAQQ,EAAIyC,IAAQuC,EAAY/C,OAAQjC,IACnEgF,EAAYf,KAAKmF,EAAOpJ,IAErBgF,EAAY/C,QACf+C,EAAYb,eAET,CAAA,GAAIsF,EAAbC,UAAuBN,GAcnB,OAbAA,EAAOjI,KACL,SAACF,GACM+D,EAAY/C,SACf+C,EAAYf,KAAUhD,GACtB+D,EAAYb,aAGhB,SAACjF,GAAa,OAAA8F,EAAYd,MAAMhF,KAEjCiC,KAAK,KAAM,SAACjC,GAEX4B,EAANuD,KAAWsF,WAAW,WAAQ,MAAMzK,MAEzB8F,EACF,GAAIoE,GAA6C,mBAA5BA,EAAOQ,EAArCxB,UAEI,IADA,IAAMA,EAAgBgB,EAAOQ,EAAjCxB,cACO,CACD,IAAIyB,EAAOzB,EAASnE,OACpB,GAAI4F,EAAKC,KAAM,CACb9E,EAAYb,WACZ,MAGF,GADAa,EAAYf,KAAK4F,EAAK5I,OAClB+D,EAAY/C,OACd,WAGC,GAAImH,GAA+C,mBAA9BA,EAAOtB,EAArCpB,YAAwE,CACpE,IAAMqD,EAAMX,EAAOtB,EAAvBpB,cACI,GAA6B,mBAAlBqD,EAAI7I,UAGb,OAAO6I,EAAI7I,UAAU,IAAImI,EAA/BR,gBAA+CM,EAAiBL,EAAYC,IAFtE/D,EAAYd,MAAM,IAAI8F,UAAU,uEAI7B,CACL,IACMC,EAAV,iBADkB/G,EAAlBC,SAA2BiG,GAAU,oBAAsB,IAAIA,EAA/D,KACA,4FAEIpE,EAAYd,MAAM,IAAI8F,UAAUC,KAElC,OAAO,iNC3ET,SAAA3I,GAAA,SAAA4I,IAA2C5I,EAA3C9C,MAAAC,KAAAC,WAcA,OAd2CoD,EAA3CoI,EAAA5I,GACE4I,EAAF5H,UAAA0G,WAAE,SAAWF,EAAeqB,EACfpB,EAAoBqB,EACpBC,GACT5L,KAAKuG,YAAYf,KAAKkG,IAGxBD,EAAF5H,UAAA2G,YAAE,SAAY/E,EAAYmG,GACtB5L,KAAKuG,YAAYd,MAAMA,IAGzBgG,EAAF5H,UAAA4G,eAAE,SAAemB,GACb5L,KAAKuG,YAAYb,YAErB+F,EAdA,CAA2C3D,EAc3C7B,oMCkDA4F,EAAA,SAAkCC,EACAC,EACAC,GAChC,YADF,IAAAA,IAAkCA,EAAqBC,OAAOC,mBACrD,SAAkCzD,GAKvC,MAJ8B,iBAAnBsD,IACTC,EAAqBD,EACrBA,EAAiB,MAEZtD,EAAOF,KAAK,IAAI4D,EAAiBL,EAAcC,EAAgBC,MAI1EG,EAAA,WACE,SAAFA,EAAsBL,EACAC,EACAC,QAAtB,IAAAA,IAAcA,EAA6BC,OAAOC,mBAF5BlM,KAAtB8L,QAAsBA,EACA9L,KAAtB+L,eAAsBA,EACA/L,KAAtBgM,WAAsBA,EAQtB,OALEG,EAAFtI,UAAAf,KAAE,SAAKsJ,EAAyB3D,GAC5B,OAAOA,EAAOhG,UAAU,IAAI4J,EAC1BD,EAAUpM,KAAK8L,QAAS9L,KAAK+L,eAAgB/L,KAAKgM,cAGxDG,EAXA,GAkBAE,EAAA,SAAAxJ,GAME,SAAFwJ,EAAc9F,EACQuF,EACAC,EACAC,QAAtB,IAAAA,IAAcA,EAA6BC,OAAOC,mBAC9CrJ,EAAJC,KAAA9C,KAAUuG,GAHYvG,KAAtB8L,QAAsBA,EACA9L,KAAtB+L,eAAsBA,EACA/L,KAAtBgM,WAAsBA,EARZhM,KAAVsM,cAAkC,EACxBtM,KAAVuM,UACUvM,KAAVwM,OAA2B,EACfxM,KAAZ+D,MAA4B,EAwE5B,OA5EiDV,EAAjDgJ,EAAAxJ,GAaYwJ,EAAZxI,UAAAgD,MAAE,SAAgBrE,GACVxC,KAAKwM,OAASxM,KAAKgM,WACrBhM,KAAKyM,SAASjK,GAEdxC,KAAKuM,OAAO5H,KAAKnC,IAIX6J,EAAZxI,UAAA4I,SAAE,SAAmBjK,GACjB,IAAImI,EACE5G,EAAQ/D,KAAK+D,QACnB,IACE4G,EAAS3K,KAAK8L,QAAQtJ,EAAOuB,GAC7B,MAAOtD,GAEP,YADAT,KAAKuG,YAAYd,MAAMhF,GAGzBT,KAAKwM,SACLxM,KAAK0M,UAAU/B,EAAQnI,EAAOuB,IAGxBsI,EAAVxI,UAAA6I,UAAE,SAAkBC,EAAyBnK,EAAUuB,GACnD/D,KAAK4E,IAAIgI,EAAbC,kBAAqC7M,KAAM2M,EAAKnK,EAAOuB,KAG3CsI,EAAZxI,UAAAkD,UAAE,WACE/G,KAAKsM,cAAe,EACA,IAAhBtM,KAAKwM,QAAuC,IAAvBxM,KAAKuM,OAAOxL,QACnCf,KAAKuG,YAAYb,YAIrB2G,EAAFxI,UAAA0G,WAAE,SAAWF,EAAeqB,EACfpB,EAAoBqB,EACpBC,GACL5L,KAAK+L,eACP/L,KAAK8M,sBAAsBzC,EAAYqB,EAAYpB,EAAYqB,GAE/D3L,KAAKuG,YAAYf,KAAKkG,IAIlBW,EAAVxI,UAAAiJ,sBAAE,SAA8BzC,EAAeqB,EAAepB,EAAoBqB,GAC9E,IAAIhB,EACJ,IACEA,EAAS3K,KAAK+L,eAAe1B,EAAYqB,EAAYpB,EAAYqB,GACjE,MAAOlL,GAEP,YADAT,KAAKuG,YAAYd,MAAMhF,GAGzBT,KAAKuG,YAAYf,KAAKmF,IAGxB0B,EAAFxI,UAAA4G,eAAE,SAAemB,GACb,IAAMW,EAASvM,KAAKuM,OACpBvM,KAAKiE,OAAO2H,GACZ5L,KAAKwM,SACDD,EAAOxL,OAAS,EAClBf,KAAK6G,MAAM0F,EAAOQ,SACO,IAAhB/M,KAAKwM,QAAgBxM,KAAKsM,cACnCtM,KAAKuG,YAAYb,YAGvB2G,EA5EA,CAAiDW,EA4EjDvB,iBCvKWwB,KACXA,EAAaC,MAAQ,EACrBD,EAAaE,UAAY,EACzBF,EAAaG,KAAO,EACpBH,EAAaI,UAAY,EACzBJ,EAAaA,EAAaC,OAAS,QACnCD,EAAaA,EAAaE,WAAa,YACvCF,EAAaA,EAAaG,MAAQ,OAClCH,EAAaA,EAAaI,WAAa,YrBEvC,IAAAC,EAAA,WAWA,SAAAA,EALKC,EAA2DC,QAAhE,IAAAD,IAAKA,EAAiCtB,OAAOC,wBAA7C,IAAAsB,IAAgEA,GAAyB,MAArFxN,KAAJuN,YAF0BtB,OAAOC,kBAQzBlM,KAAKyN,SACLzN,KAAK0N,cAAgB,IAAIC,EAAAA,aACzB3N,KAAK4N,QACL5N,KAAKwN,aAAeA,EACpBxN,KAAKuN,YAAcA,EACnBvN,KAAK6N,sBAqUb,OAhUAP,EAAAzJ,UAAAgK,oBAAA,WAAA,IAAAlG,EAAA3H,KACQA,KAPK8N,gBAAkB,IAAIC,EAAAA,QAQ3B/N,KAPK8N,gBAQAxE,KACG0E,EAPS,SAAAC,GAAU,OAAAtG,EAAKuG,YAAYD,IAASjO,KAAKuN,cASrD9K,UAPU,SAAA0L,GAAgB,OAAAxG,EAAK+F,cAAcU,KAAKD,MAc/Db,EAAAzJ,UAAAwK,YAAA,SAVKC,GAUL,IAAA3G,EAAA3H,KATcuO,KAAkChO,OAAOuC,KAAKwL,EAAe,SAAAE,EAAcC,EAAiBlN,GAW9F,GAAIoG,EAVK+G,qBAAqBD,EAAUE,MAWpCH,EAVMA,EAAI9N,OAAO+N,OACd,CAWH,IAVMG,EAA2BjH,EAAKkH,eAAeJ,EAAWlN,GAWhEoG,EAVK+F,cAAcU,MAAMO,KAAM,WAAYG,KAAMF,IAarD,OAVOJ,QAaXO,EAAA/O,KAVKyN,OAAM9I,KAUnB5E,MAAAgP,KAV8BhM,IAAID,KAAKyL,EAAsB,SAAAO,EAAavN,GAW9D,IAVMyN,EAAyBrH,EAAKkH,eAAeC,EAAMvN,GAYzD,OADAoG,EAVK+F,cAAcU,MAAMO,KAAM,eAAgBG,KAAME,IAC9CA,KAaXhP,KAVK0N,cAAcU,MAAMO,KAAM,2BAgBvCrB,EAAAzJ,UAAAoL,gBAAA,SAbKjO,GAaL,IAAA2G,EAAA3H,KACQ,OAbOgB,EAAMyB,UAAU,SAACyM,GAcpB,OAAQA,EAbMP,MAcV,IAbK,aAcD,IAbMQ,EAAkBxH,EAAK8F,MAAM2B,UAAU,SAAAN,GAAQ,OAAAA,IAASI,EAAMJ,QAC5C,IAapBK,GAb0BD,EAAMJ,MAchCnH,EAbKmG,gBAAgBtI,MAAMsJ,KAAMnH,EAAK8F,MAAM0B,GAAkBD,MAAOA,IAezE,MACJ,IAbK,YACavH,EAAK8F,MAAM4B,OAAO,SAAAP,GAAQ,OAAAA,EAAKQ,SAASC,SAAWtC,EAAaC,QACxEpE,QAAQ,SAAAgG,GAAQ,OAAAnH,EAAKmG,gBAAgBtI,MAAMsJ,KAAMA,EAAMI,MAAOA,MAcpE,MACJ,IAbK,SAcD,IAbMM,EAAKN,EAAMO,IAAM,KAcvB,IAbKD,EAcD,OAGJ,IAbMzL,EAAQ4D,EAAKiG,KAAKwB,UAAU,SAAA5K,GAAO,OAAAA,EAAIiL,KAAOD,IAcpD,IAbc,IAaVzL,GAbgB4D,EAAKiG,KAAK7J,GAAOS,IAAK,CActCmD,EAbKkG,sBAcLlG,EAbKiG,KAAK7J,GAAOS,IAAIjB,cAerB,IAbMmM,EAAY/H,EAAK8F,MAAM2B,UAAU,SAAAN,GAAQ,OAAAA,EAAKW,KAAOD,KACzC,IAadE,IACA/H,EAbK8F,MAAMiC,GAAWJ,SAASC,OAAStC,EAAaI,UAcrD1F,EAbK+F,cAAcU,MAAMO,KAAM,YAAaG,KAAMnH,EAAK8F,MAAMiC,MAgBrE,MACJ,IAbK,YAcD/H,EAbKiG,KAAK9E,QAAQ,SAAAtE,GAcVA,EAbIA,KAcJA,EAbIA,IAAIjB,cAgBZ,IAbMuL,EAAOnH,EAAK8F,MAAMkC,KAAK,SAAAX,GAAc,OAAAA,EAAWS,KAAOjL,EAAIiL,KAc7DX,IACAA,EAbKQ,SAASC,OAAStC,EAAaI,UAcpC1F,EAbK+F,cAAcU,MAAMO,KAAM,YAAaG,KAAMA,OAgB1D,MACJ,IAbK,SAcD,IAbKI,EAAMO,GAcP,OAGJ,IAbMlO,EAAIoG,EAAK8F,MAAM2B,UAAU,SAAAN,GAAQ,OAAAA,EAAKW,KAAOP,EAAMO,KAczD,IAbU,IAaNlO,EAbU,CAcV,IAbMuN,EAAOnH,EAAK8F,MAAMlM,GAcxBoG,EAbK8F,MAAMpI,OAAO9D,EAAG,GAcrBoG,EAbK+F,cAAcU,MAAMO,KAAM,UAAWG,KAAMA,IAepD,MACJ,IAbK,YAcGnH,EAbK8F,MAAM1M,SAcX4G,EAbK8F,SAcL9F,EAbK+F,cAAcU,MAAMO,KAAM,oBAuBvDrB,EAAAzJ,UAAAqK,YAAA,SAhBKD,GAgBL,IAAAtG,EAAA3H,KACQ,OAhBO,IAAIsI,EAAAA,WAAW,SAAA8D,GAiBlB,IAhBM5H,EAAMmD,EAAKqH,WAAWf,EAAOa,KAAMb,EAAOiB,OAiB3CzM,UAhBU,SAAAmN,GAiBPxD,EAhBS5G,KAAKoK,IACf,SAAAnP,GAiBC2L,EAhBS3G,MAAMhF,GAiBf2L,EAhBS1G,YACV,WAiBC0G,EAhBS1G,aAmBjBiC,EAhBKiG,KAAKjJ,MAAM8K,GAAIxB,EAAOa,KAAKW,GAAIjL,IAAKA,OAwBrD8I,EAAAzJ,UAAAmL,WAAA,SApBKF,EAAAI,GAoBL,IAAAvH,EAAA3H,KACQ,OApBO,IAAIsI,EAAAA,WAAW,SAAA8D,GAqBlB,IApBMyD,EAAMX,EAAMW,KAAO,GACnBC,EAASZ,EAAMY,QAAU,OACzBC,EAAOb,EAAMa,SACbC,EAAUd,EAAMc,YAEhBC,EAAM,IAAIC,eACVC,GAAe,IAAIC,MAAOC,UAC5BC,EAA4BxB,EAAMQ,SAASS,MAAQjB,EAAKQ,SAASS,KAAKQ,WAAcJ,EACpFK,EAAQ,EACRC,EAAqB,KAsBzBR,EApBIhC,OAAOyC,iBAAiB,WAAY,SAAAxQ,GAqBpC,GAAIA,EApBEyQ,iBAAkB,CAqBpB,IApBMC,EAAapP,KAAKqP,MAAkB,IAAX3Q,EAAE4Q,OAAgB5Q,EAAE6Q,OAC7CC,GAAO,IAAIZ,MAAOC,UAAYF,EAqBpCK,EApBQhP,KAAKqP,MAAM3Q,EAAE4Q,OAASE,EAAO,KAqBrCV,EApBoBxB,EAAMQ,SAASS,MAAQjB,EAAKQ,SAASS,KAAKQ,YAAc,IAAIH,MAAOC,UAqBvFI,EApBMjP,KAAKyP,MAAM/Q,EAAE6Q,MAAQ7Q,EAAE4Q,QAAUN,GAsBvC1B,EApBKQ,UAqBDC,OApBQtC,EAAaE,UAqBrB4C,MACIa,WApBYA,EAqBZJ,MApBOA,EAqBPU,WApBY7P,EAAiBmP,GAoBzD,KAC4BD,UApBWD,EAqBXa,QApBS,KAqBTV,IApBKA,EAqBLW,SApBUzJ,EAAK0J,eAAeZ,KAwBtCrE,EApBS5G,MAAMmJ,KAAM,YAAaG,KAAMA,OAE7C,GAsBHmB,EApBIhC,OAAOyC,iBAAiB,QAAS,SAAAxQ,GAqBjCkM,EApBS3G,MAAMvF,GAqBfkM,EApBS1G,aAuBbuK,EApBIqB,mBAAqB,WAqBrB,GAAIrB,EApBIsB,aAAerB,eAAesB,KAAM,CAqBxC,IApBMC,EAAejQ,KAAKqP,MAAM/B,EAAK4C,OAAO,IAAKtB,MAAOC,UAAYC,GAAqB,KAqBzFxB,EApBKQ,UAqBDC,OApBQtC,EAAaG,KAqBrB2C,MACIa,WApBY,IAqBZJ,MApBOiB,EAqBPP,WApBY7P,EAAiBoQ,GAoBzD,KAC4BlB,UApBWD,EAqBXa,SApBS,IAAIf,MAAOC,UAqBpBI,IApBKA,EAqBLW,SApBUzJ,EAAK0J,eAAeZ,GAAO,KAwB7C3B,EApBK6C,eAAiB1B,EAAIV,OAsB1B,IACIT,EApBK8C,SAAWC,KAAKC,MAAM7B,EAAI2B,UAsBnC,MAAwB1R,GACpB4O,EApBK8C,SAAW3B,EAAI2B,SAuBxB9C,EApBKiD,gBAAkBpK,EAAKqK,qBAAqB/B,EAAIgC,yBAsBrD7F,EApBS5G,MAAMmJ,KAAM,OAAQG,KAAMA,IAsBnC1C,EApBS1G,aAwBjBuK,EApBIiC,KAAKpC,EAAQD,GAAK,GAqBtBI,EApBIkC,kBAAkBjD,EAAMiD,gBAsB5B,IACI,IApBMC,EAAuBtD,EAAM,WAC7BuD,EAAc1K,EAAK8F,MAAM2B,UAAU,SAAAkD,GAAW,OAAAA,EAAQC,aAAeH,IAsBvEzK,EApBK8F,MAAM4E,GAAa/C,SAASC,SAAWtC,EAAaI,WAqBzDjB,EApBS1G,WAuBb4B,OApBO0C,KAAK+F,GAAMjH,QAAQ,SAAAoB,GAAO,OAAA4E,EAAK0D,KAAKC,OAAOvI,EAAK6F,EAAK7F,MAqB5D5C,OApBO0C,KAAKgG,GAASlH,QAAQ,SAAAoB,GAAO,OAAA+F,EAAIyC,iBAAiBxI,EAAK8F,EAAQ9F,MAsBtE4E,EApBK0D,KAAKC,OAAOvD,EAAMyD,WAAa,OAAQP,EAAYA,EAAWlP,MAsBnEyE,EApBK+F,cAAcU,MAAMO,KAAM,QAASG,KAAMA,IAqB9CmB,EApBI2C,KAAK9D,EAAK0D,MAsBlB,MAAwBtS,GACpBkM,EApBS1G,WAuBb,OApBO,WAqBHuK,EApBI4C,YA4BpBvF,EAAAzJ,UAAAwN,eAAA,SAvBKyB,GAwBG,OAvBO,IAAI1C,KAAW,IAAN0C,GAAYC,cAAcC,OAAO,GAAI,IA4B7D1F,EAAAzJ,UAAAoP,WAAA,WACQ,OAzBOzR,KAAK0R,SAASlQ,SAAS,IAAImQ,UAAU,IA+BpD7F,EAAAzJ,UAAAuP,gBAAA,SA5BK5F,QAC8B,IAAhBA,GAA+BA,aAAwB7K,MA6B1D6K,EA5BamC,KAAK,SAAChB,GAAiB,MAAS,MAATA,MAAkB0E,UA6BtDrT,KA5BKwN,cAAe,KA8BpBxN,KA5BKwN,aAAeA,EAgC5BxN,KA5BKwN,cAAe,MAiC5BF,EAAAzJ,UAAAyP,uBAAA,WACQ,OA9BOtT,KAAKwN,aAAamC,KAAK,SAAChB,GAAiB,MAAS,MAATA,MAAkB0E,WAoC1E/F,EAAAzJ,UAAA6K,qBAAA,SAjCK6E,GAkCG,QAAIvT,KAjCKsT,0BAGFtT,KAAKwN,aAAamC,KAAK,SAAChB,GAAiB,OAAAA,IAAS4E,MAAcF,WAwC/E/F,EAAAzJ,UAAAgL,eAAA,SArCKC,EAAA/K,GAsCG,OACI2L,UArCW3L,EAsCX0L,GArCIzP,KAAKiT,aAsCT/P,KArCM4L,EAAK5L,KAsCXwO,KArCM5C,EAAK4C,KAsCX/C,KArCMG,EAAKH,KAsCX6D,KArCM,IAAIgB,SAsCVlE,UACIC,OArCQtC,EAAaC,MAsCrB6C,MACIa,WArCY,EAsCZJ,MArCO,EAsCPU,WArCY7P,EAAiB,GAqCjD,KACoBkP,UArCW,KAsCXY,QArCS,KAsCTV,IArCK,KAsCLW,SArCU,OAwClBqC,iBArCkB3E,EAAK2E,iBAsCvBjP,IArCK6O,UAsCLd,WArCYzD,IAInBxB,EAALzJ,UAAAmO,qBAAK,SAAA0B,GAyCG,GAxCKA,EA2CL,OAxCOA,EAAYC,MAAM,MAyCpB5Q,IAxCI,SAAAR,GAAK,OAAAA,EAAEoR,MAAM,MAAO,KAyCxBtE,OAxCO,SAAA9M,GAAK,OAAAA,EAAE,KAyCdhC,OAxCO,SAACqT,EAAIrR,GA0CT,OADAqR,EAxCGrR,EAAE,IAAMA,EAAE,GACNqR,QA2CvBtG,EAtVA,GsBlBAuG,EAAA,WAYA,SAAAA,EAAqBC,GAArB,IAAAnM,EAAA3H,KAAqBA,KAArB8T,WAAqBA,EAmCnB9T,KAAF+T,aAJiB,WAKTpM,EAJKqM,GAAGC,OAKVtM,EAJKsG,OAAOI,YAAY1G,EAAKqM,GAAGC,QAhClCjU,KAAKmO,aAAe,IAAIR,EAAAA,oBAK5BkG,EAAAhQ,UAAAqQ,SAAA,WAAA,IAAAvM,EAAA3H,KACIA,KAFKmU,QAGL,IAFM5G,EAAcvN,KAAKoU,SAAWpU,KAAKoU,QAAQ7G,aAAetB,OAAOC,kBACjEmI,EAAsBrU,KAAKoU,SAAWpU,KAAKoU,QAAQC,sBAAuB,KAGhFrU,KAFKiO,OAAS,IAAIX,EAAkBC,EAAa8G,GAIjDrU,KAFKgU,GAAKhU,KAAK8T,WAAWQ,cAG1BtU,KAFKgU,GAAGtD,iBAAiB,SAAU1Q,KAAK+T,cAAc,GAItD/T,KAFKmU,KAAKxP,KAGR3E,KAFKiO,OAAOP,cAAcjL,UAAU,SAACyM,GAGnCvH,EAFKwG,aAAaC,KAAKc,MAMvBlP,KAFKuU,uBAAuB5G,EAAAA,cAG9B3N,KAFKmU,KAAKxP,KAAK3E,KAAKiO,OAAOgB,gBAAgBjP,KAAKuU,eAQtDV,EAAAhQ,UAAA2Q,YAAA,WACQxU,KAJKgU,KAKPhU,KAJKgU,GAAGS,oBAAoB,SAAUzU,KAAK+T,cAAc,GAKzD/T,KAJKmU,KAAKrL,QAAQ,SAAAtE,GAAO,OAAAA,EAAIjB,oBAvCnC,GAgDOsQ,EAAPa,aACE/F,KAAMgG,EAAAA,UAAWC,OAKjBC,SAJU,qBAIXhB,EAADiB,eAAC,WAAA,QAOAnG,KAAMoG,EAAAA,cAJAlB,EAAPmB,gBAOAZ,UANczF,KAAMsG,EAAAA,QAOpBV,cANkB5F,KAAMsG,EAAAA,QAOxB9G,eANmBQ,KAAMuG,EAAAA,UC5DzB,IAAAC,EAAA,WAYA,SAAAA,EAAqBrB,GAAA9T,KAArB8T,WAAqBA,EAmCnB9T,KAAFoV,UAJc,SAAAlV,GAKVA,EAJEmV,kBAKFnV,EAJEoV,kBAhCFtV,KAAKmO,aAAe,IAAIR,EAAAA,oBAK5BwH,EAAAtR,UAAAqQ,SAAA,WAAA,IAAAvM,EAAA3H,KACIA,KAFKmU,QAGL,IAFM5G,EAAcvN,KAAKoU,SAAWpU,KAAKoU,QAAQ7G,aAAetB,OAAOC,kBACjEmI,EAAsBrU,KAAKoU,SAAWpU,KAAKoU,QAAQC,sBAAuB,KAGhFrU,KAFKiO,OAAS,IAAIX,EAAkBC,EAAa8G,GAIjDrU,KAFKgU,GAAKhU,KAAK8T,WAAWQ,cAI1BtU,KAFKmU,KAAKxP,KAGR3E,KAFKiO,OAAOP,cAAcjL,UAAU,SAACyM,GAGnCvH,EAFKwG,aAAaC,KAAKc,MAMvBlP,KAFKuU,uBAAuB5G,EAAAA,cAG9B3N,KAFKmU,KAAKxP,KAAK3E,KAAKiO,OAAOgB,gBAAgBjP,KAAKuU,cAKlDvU,KAFKgU,GAAGtD,iBAAiB,OAAQ1Q,KAAKoV,WAAW,GAGjDpV,KAFKgU,GAAGtD,iBAAiB,YAAa1Q,KAAKoV,WAAW,GAGtDpV,KAFKgU,GAAGtD,iBAAiB,WAAY1Q,KAAKoV,WAAW,IAOzDD,EAAAtR,UAAA2Q,YAAA,WACIxU,KAJKmU,KAAKrL,QAAQ,SAAAtE,GAAO,OAAAA,EAAIjB,iBAS9B4R,EAAHtR,UAAA0R,OAAG,SAAArV,GAOCA,EANEmV,kBAOFnV,EANEoV,iBASFtV,KANKmO,aAAaC,MADYO,KAAM,SAQpC3O,KANKiO,OAAOI,YAAYnO,EAAEsV,aAAavB,QAIxCkB,EAAHtR,UAAA4R,WAAG,SAAAvV,GASC,GARKA,EAQL,CAKAF,KARKmO,aAAaC,MADYO,KAAM,eAKrCwG,EAAHtR,UAAA6R,YAAG,SAAAxV,GAWC,GAVKA,EAUL,CAKAF,KAVKmO,aAAaC,MADYO,KAAM,gBA1ExC,GA6EOwG,EAAPT,aACE/F,KAAMgG,EAAAA,UAAWC,OAWjBC,SAVU,mBAIXM,EAADL,eAAC,WAAA,QAaAnG,KAAMoG,EAAAA,cAVAI,EAAPH,gBAaAZ,UAZczF,KAAMsG,EAAAA,QAapBV,cAZkB5F,KAAMsG,EAAAA,QAaxB9G,eAZmBQ,KAAMuG,EAAAA,SAazBK,SAZa5G,KAAMgH,EAAAA,aAAcf,MAAM,QAAS,aAahDa,aAZiB9G,KAAMgH,EAAAA,aAAcf,MAAM,YAAa,aAaxDc,cAZkB/G,KAAMgH,EAAAA,aAAcf,MAAM,aAAc,cC5F1D,IAAAgB,EAAA,kBAAA,aAAA,GAEsCA,EAAtClB,aACE/F,KAAMkH,EAAAA,SAAUjB,OADhBkB,cACEjC,EACAsB,GAEFtP,SACEgO,EACAsB,OAOHS,EAADd,eAAC,WAAA"}
